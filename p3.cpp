#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
static const uint64_t CHRONO_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
static const uint64_t PIDRNDP = (uint64_t)(CHRONO_RANDOM)*0xbffbffbffULL;//getpid is often blocked. therefore, use chrono AGAIN
static mt19937_64 PIDRNG(PIDRNDP);
static const uint64_t PIDRND = PIDRNG();
static const uint64_t FIXED_RANDOM = CHRONO_RANDOM ^ PIDRND;
struct CHASH {
    template <typename T>
    size_t operator()(const T& x) const {
        return hash<T>{}(x) ^ FIXED_RANDOM;
    }
    template <typename T1, typename T2>
    size_t operator()(const pair<T1, T2>& x) const {
        return (*this)(x.first) ^ ((*this)(x.second) + 0x9e3779b9 + (x.first << 6) + (x.first >> 2));
    }
};
template<typename T1,typename T2>
using hashmap=unordered_map<T1,T2,CHASH>;
template<typename TM>
using matrix=vector<vector<TM>>;
template<typename TM>
using tensor=vector<matrix<TM>>;
#define all(x) (x).begin(),(x).end()
#define forn(i,n) for(int i=0;i<(n);++i)
#define MULTITEST false
#define in(x) cin>>x
#define out(s) cout<<s<<'\n';
#define firn(i,s,n) for(int i=(s);i<(n);++i)
void solve(){
	int n,q,a,b;cin>>n;
	vector<int> x(n);for(int &z:x)in(z);
	vector<ll> cm{0};vector<int> dx{0};
	sort(all(x));in(q);
	for(int z:x)cm.push_back(cm.back()+z);
	function<ll(int,int)> cmsum=[&](int l,int r)->ll{return cm[r+1]-cm[l];};	
	firn(i,1,n)if(x[i]>x[i-1])dx.push_back(i);
	while(q--){
		in(a>>b);
		function<ll(int)> eval=[&](int idx)->ll{return (b*(cmsum(dx[idx],n-1)-(ll)(n-dx[idx])*x[dx[idx]]))+(a*((ll)dx[idx]*x[dx[idx]]-cmsum(0,dx[idx]-1)));};
		int lo=0,hi=dx.size()-1;
		while(lo<hi){ // beenary scorch
			int mid = lo+(hi-lo)/2;//no overflow
			if(eval(mid)<eval(mid+1))hi=mid;
			else lo=mid+1;
		}
		out(eval(lo));
	}
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	int t=1;
	if (MULTITEST) in(t);
	forn(i,t)solve();
}




































































































































































































































































































































































































































































































































































































































































































// wysi;gyze full-filled in lambda function syntax turns me on (jk);
