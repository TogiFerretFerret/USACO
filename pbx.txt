 
Contest Results






(Analysis by David Hu, Benjamin Qi)
Sort all of the xixi (zero-indexed) in increasing order. Consider some fixed
individual query (ai,bi)=(a,b)(ai,bi)=(a,b).
Suppose that Farmer John delivers the haybales to some point
xi−1<y<xixi−1<y<xi. Consider what happens if Farmer John instead delivers the
haybales to some point xi−1<y+d<xixi−1<y+d<xi. The total cost Farmer John
pays changes by a⋅da⋅d for each of the ii haybales to the left of the
starting point and −b⋅d−b⋅d for each of the N−iN−i haybales to the right of
the starting point, making an overall change of
a⋅i⋅d−b⋅(N−i)⋅da⋅i⋅d−b⋅(N−i)⋅d. Since this is linear in dd, the
cost to start at point yy is linear in the range y∈[xi−1,xi]y∈[xi−1,xi]. Thus
it is always optimal for the haybales to be delivered to one of the xixi.
Full Solution 1: O(1)O(1) time per query
Suppose Farmer John is deciding whether to deliver the haybales to xi−1xi−1 or
xixi. Let the distance between xi−1xi−1 and xixi be d>0d>0.
If he delivers the haybales to xi−1xi−1, then the total cost for delivering
each of the ii haybales x0,…xi−1x0,…xi−1 is d⋅ad⋅a less, but the total
cost for delivering each of the N−iN−i haybales xi,…xN−1xi,…xN−1 is
d⋅bd⋅b more. Thus in order for xi−1xi−1 to be a strictly better place to
deliver the haybales than xixi,
d⋅a⋅i>d⋅b⋅(N−i)⟹N−ii<ab⟹Ni<a+bb⟹i>Nba+bd⋅a⋅i>d⋅b⋅(N−i)⟹N−ii<ab⟹Ni<a+bb⟹i>Nba+b.
We conclude that the following statements hold (even when d=0d=0):
If i>⌊Nba+b⌋i>⌊Nba+b⌋, it is at least as good
to deliver the haybales to xi−1xi−1 rather than xixi.If
i<⌊Nba+b⌋i<⌊Nba+b⌋, it is at least as good to
deliver the haybales to xi+1xi+1 rather than xixi.
So in fact we know the exact optimal location for Farmer John to deliver the
haybales to: it is xixi, where
i=⌊Nba+b⌋i=⌊Nba+b⌋.
To answer queries in O(1)O(1), we can precompute the sum of distances to all
haybales to the left of and to the right of each haybale.
David's code:
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 13;
int N, Q;
int arr[MAXN];
ll lt[MAXN], rt[MAXN];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cin >> N;
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }
    sort(arr, arr + N);
    for (int i = 1; i < N; i++) {
        int d = arr[i] - arr[i - 1];
        lt[i] = lt[i - 1] + (ll) d * i;
    }
    for (int i = N - 2; i >= 0; i--) {
        int d = arr[i + 1] - arr[i];
        rt[i] = rt[i + 1] + (ll) d * (N - 1 - i);
    }
    cin >> Q;
    while(Q--) {
        int a, b;
        cin >> a >> b;
        int idx = (ll) N * b / (a + b);
        ll ans = lt[idx] * a + rt[idx] * b;
        cout << ans << '\n';
    }
    return 0;
}

Full Solution 2: O(logN)O(log⁡N) time per query
For a single xx, the function in the problem statement is a 
convex function of yy. 
The total number of haybales wasted across all xx is given by a sum of a convex
functions, which is also convex. Any convex function is unimodal (specifically,
it strictly decreases until the minimum is reached, then strictly increases),
and thus can be minimized using binary or
ternary search.
As in the first full solution, we precompute prefix sums so that evaluating the
number of wasted haybales when yy equals some xixi takes O(1)O(1) time.
Note: Make sure to search only on distinct values of xx, or you might end up
with the wrong answer.
Ben's code:
#include <bits/stdc++.h>
using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int N;
	cin >> N;
	vector<int> X(N);
	for (int &x : X) cin >> x;
	sort(begin(X), end(X));
	int Q;
	cin >> Q;
	vector<int64_t> cum{0};
	for (int x : X) cum.push_back(cum.back() + x);
	auto cumsum = [&](int l, int r) { return cum.at(r + 1) - cum.at(l); };
	vector<int> distinct_X{0};  // keep only distinct X[i]
	for (int i = 1; i < N; ++i)
		if (X[i] > X[i - 1]) distinct_X.push_back(i);
	while (Q--) {
		int A, B;
		cin >> A >> B;
		auto eval = [&](int idx) {
			int i = distinct_X.at(idx);
			int64_t ans = B * (cumsum(i, N - 1) - (int64_t)(N - i) * X[i]);
			ans += A * ((int64_t)i * X[i] - cumsum(0, i - 1));
			return ans;
		};
		int lo = 0, hi = size(distinct_X) - 1;
		while (lo < hi) {
			int mid = (lo + hi) / 2;
			if (eval(mid) < eval(mid + 1)) hi = mid;
			else lo = mid + 1;
		}
		cout << eval(lo) << "\n";
	}
}



